http://www.tuicool.com/articles/B7FBb2

优化

要实现O(n)的时间复杂度，就不能对数组排序。其实我们大脑在判断这个问题时就是不排序的。让我们来模拟一下：

你看到[100, 4, 200, 1, 3, 2]这个数组，首先你会看99或者101在不在这个数组里，发现数组没这两个数，那么100组成的连续序列长度仅为1。接着会看5或者3在不在数组里，会发现3存在，5不存在；紧接着会看2在不在....直到发现0不在。从而得到4组成的最长序列为4。

总结一下会发现，我们在判断某个数的连续序列时，会分别往减小和增大的方向找下一个连续数在不在数组中。然后把两个方向的长度加起来即为包含该数的一个连续序列。需要注意的是，当前数的长度计数只需要出现在一个方向的查找中计算即可，否则就重复了。要找一个数是不是在数组中，不可能用遍历的方法实现，这样时间复杂度就超过O(n)了。而要降低时间复杂度，一个经典的方案就是空间换时间。用增加空间复杂度的方法来换取时间复杂度的降低。所以我们可以先对数组进行一次预处理，生成一份包含数组元素的哈希表。这样在求解某个数字在不在数组时就可以得到O(1)的时间复杂度。

那么我们可以得到如下伪代码：

找连续序列函数(要找序列的值，方向)

  循环直到要找的值不在哈希表中

    序列长度+1

    如果增加方向，要找的序列值+1

    如果减少方向，要找的序列值-1

  循环结束

  返回序列长度

找连续序列函数结束

求解函数(数组)

  遍历数组生成哈希表

  遍历数组

    序列长度1 = 找连续序列函数(当前值，增加方向)

    序列长度2 = 找连续序列函数(当前值 - 1，减少方向)

    如果序列长度1 + 序列长度2 > 当前最长序列，更新最长序列

  遍历结束

求解函数结束

这个方案的时间复杂度应该是O(n) + O(n) * O(1) * O(平均序列长度)。如果平均序列长度等于n，如数组[3,4,2,1]，复杂度就是O(n^2)了。看来还不可行，主要的时间复杂度都浪费在找连续序列上了。怎么能减少找连续序列的时间复杂度？经过观察我们可以发现，4的最长序列和3，2，1的最长序列其实是一样的。找过了4之后其实后面这3个数都不用找了。而我们控制是否查找一个数的连续序列是通过判断数字是否在哈希表中来实现的，也就是说，如果我们可以在找出一个数字在连续序列中后就将其移除，就可以避免以后再触发查找的循环。通过这个优化，时间复杂度将变为O(n) + O(n) + O(序列长度总和)，可以认为是O(n)了。最后得出代码如下：
